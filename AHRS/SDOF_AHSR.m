%% xyz 2015.4.21



function SDOF_AHSR(  )

% clc
clear all
close all

dataFolder = 'E:\data_xyz_noitom\AHRS Data\ahrs_raw_data_4.20\Xu';
refDataFolder = [dataFolder,'\ref'];
%  dataFolder = 'E:\data_xyz_noitom\AHRS Data\staticData_4.21_250HZ';
% dataFolder = 'E:\data_xyz_noitom\AHRS Data\staticData_4.21';
dataName = 'ahrs1' ;
% dataName = 'static3';

AHRSData = importdata( [ dataFolder,'\',dataName,'.mat' ] );
Nframes  = length(AHRSData.accNorm);
AHRSData.Nframes = Nframes ;

%% 转台参考数据：第二列是测量值，°，1000HZ
AHRSRefData_Raw = importdata( [ refDataFolder,'\',dataName,'.dat' ] );
RefRotateAngle = ( AHRSRefData_Raw(:,2)-30 ) *pi/180 ;
%%% 找到正弦的0点作为起点
k = 1 ;
while k<length(RefRotateAngle) 
   if sign( RefRotateAngle(k) )+sign( RefRotateAngle(k+1) ) ==0 || RefRotateAngle(k) == 0
       RefRotateAngle = RefRotateAngle( k:length(RefRotateAngle)  );       
       break;
   end
   k = k+1 ;
end

AHRSRefData.frequency = 1000 ;

NframesNew = fix( length(RefRotateAngle)* AHRSData.frequency / AHRSRefData.frequency ) ;
NframesNew = min( NframesNew,Nframes );
RefRotateAngleNew = zeros(1,NframesNew);
for k=1:NframesNew
    k_raw = fix( k* AHRSRefData.frequency / AHRSData.frequency);
    RefRotateAngleNew(k) = RefRotateAngle(k_raw);
end
AHRSRefData.RefRotateAngle = RefRotateAngleNew ;
%%
RotateAngle = SDOF_AHSR_One( AHRSData,AHRSRefData ) ;

%% 
function RotateAngle = SDOF_AHSR_One( AHRSData,AHRSRefData )

%% load data
% quaternion = AHRSData.quaternion ;
gyro = AHRSData.gyro ;
acc = AHRSData.acc ;
gyroNorm = AHRSData.gyroNorm ;
accNorm = AHRSData.accNorm ;
frequency = AHRSData.frequency ;
Nframes = AHRSData.Nframes ;
time = Nframes/frequency ;

%% static time judge
%%% the threshold value to judge is being static
%%% 动态变化过程中，0加速度时刻的判断 指标
AHRSThreshod.GyroNormZeroThreshod = 0.7 *pi/180 ;       % 0.5 °/s  角速度为0判断下限
AHRSThreshod.AccNormZeroThreshod = 2/1000 ;             % 3mg  加速度模为0判断下限
AHRSThreshod.InitialIsStaticSmoothStepTime = 0.5 ;      % 动态静止平滑步长时间
AHRSThreshod.DynamicIsStaticSmoothStepTime = 0.05 ;     % 动态静止平滑步长时间
AHRSThreshod.GyroContinuousZeroTimeThreshod = 0.3 ;     % 角速度变化率=0判断：角速度为0保持时间
AHRSThreshod.GyroContinuousZeroMinRate = 0.7 ;          % 角速度变化率=0判断：角速度为0在邻域内保持的比例
AHRSThreshod.IsContinuousGyroNormZeroSmoothStepTime = 0.2  ; % 角速度变化率为0判断结果平滑步长 （可以稍微长点）
%%% 初始零位判断指标
AHRSThreshod.InitialIsStaticJudgeStepTime = 0.1 ;       % 初始静止判断步长时间
AHRSThreshod.InitialStaticAbandonTime = 0.05 ;          % 初始静止时段首尾抛弃时长
%%% 转轴计算指标
AHRSThreshod.RoateVectorCalMinAngleFirst = 10*pi/180;   % 假设航向保持0时，俯仰和横滚转动四元数的转角大于 RoateVectorCalMinAngleFirst 角度时，用于旋转轴的第一次计算
AHRSThreshod.RoateVectorCalMinAngleSecond = 20*pi/180;  % 根据初次转轴解算结果，选择转动角度大于 RoateVectorCalMinAngleSecond 的进行转轴的详细解算
AHRSThreshod.RoateVectorCalMinAngleScope = 10*pi/180 ;  % 转轴计算数据选择的转角范围，如果第二次旋转的转角小于这个范围，发出警告
AHRSThreshod.RoateVectorCalMinAngleScopeSub = 1*pi/180 ;% 正转角的转角范围 和 负转角的转角范围 的最大值
AHRSThreshod.RoateVectorCalTime  = 15 ;                 % 从静止开始多次时间的数据用于转轴计算。之后就要求输出角度。


% dbstop in Judge0Acceleration
[ IsSDOFAccelerationZero,initialStaticStart,initialStaticEnd,IsSDOFAccelerationToHeartZero,IsAccNormZero ] = Judge0Acceleration( AHRSData,AHRSThreshod ) ;
SDOFStaticFlag.IsSDOFAccelerationZero = IsSDOFAccelerationZero ;
SDOFStaticFlag.IsSDOFAccelerationToHeartZero = IsSDOFAccelerationToHeartZero ;
SDOFStaticFlag.IsAccNormZero = IsAccNormZero ;

AHRSStateResult.IsSDOFAccelerationZero = IsSDOFAccelerationZero ;
initialStaticTime = ( initialStaticEnd-initialStaticStart )/frequency ;
if initialStaticTime < 1
   errordlg(sprintf('初始静止状态时长=%0.2f sec， 太短！',initialStaticTime)); 
end
%% calculate the rotate vector
[ pitch,roll,Qnb ] = Acc2PitchRoll( acc ) ;
%%% initial static acc  gyro  : r frame
accStatic = acc( initialStaticStart:initialStaticEnd,: ) ;
acc_r = mean( accStatic,1 );
gyroStatic = gyro( initialStaticStart:initialStaticEnd,: ) ;
gyro_r = mean( gyroStatic,1 );
[ pitch_r,roll_r,Qwr ] = Acc2PitchRoll( acc_r ) ;

pitch_d = pitch*180/pi;
roll_d = roll*180/pi;

pitch_r_d = pitch_r*180/pi;
roll_r_d = roll_r*180/pi;


%% 转轴解算
%%% 截取零位计算时段的数据 Qnb_ZeroCal
RoateVectorCalTime = AHRSThreshod.RoateVectorCalTime ; 
RoateVectorCalN = RoateVectorCalTime*frequency ;
Qnb_ZeroCal = Qnb( :,1:RoateVectorCalN ) ;
IsSDOFAccelerationZero_ZeroCal = IsSDOFAccelerationZero(1:RoateVectorCalN);

Ypr = GetRotateVector_Acc( Qnb_ZeroCal,Qwr,AHRSThreshod,SDOFStaticFlag ) ;

%% 纯加计转角解算
RotateAngle = CalculateRotateAngle_Acc( Qnb,Qwr,Ypr ) ;



%%
stepN = 20 ;
k=stepN+1;
while k<length(RotateAngle)-stepN
   sum_sign1 =  sum ( sign( RotateAngle(k-stepN:k-1) ) )  ;
   sum_sign2 =  sum ( sign( RotateAngle(k+1:k+stepN) ) )  ;
   if sum_sign1 > stepN-1 && sum_sign2 < -stepN+1
       RotateAngleNew = RotateAngle( k:length(RotateAngle) );
       break;
   end
   k=k+1;
end

RefRotateAngle = AHRSRefData.RefRotateAngle ;
N = min( length(RotateAngleNew),length(RefRotateAngle) );
RotateAngleErr = RotateAngleNew(1:N) - RefRotateAngle(1:N) ;

RotateAngleErr_Mean = mean(RotateAngleErr)*180/pi;
RotateAngleErr_Std = std(RotateAngleErr)*180/pi;

figure
plot(RotateAngleErr*180/pi)

figure
plot( RotateAngleNew(1:N)*180/pi,'b' )
hold on
plot( RefRotateAngle(1:N)*180/pi,'r' )
% plot(RotateAngleErr*180/pi,'k,')

legend('RotateAngleNew','RefRotateAngle')
%%
return
staticTime = 18 ;
staticNum = frequency*staticTime ;   % 3 sec

% DrawAHRSData( AHRSData,'raw' ) ;

meam_gyro = GetStaticStateFeature( AHRSData,staticNum ) ;
if staticTime>15
     gyroNew = gyro - repmat( meam_gyro,Nframes,1 );
     gyroNormNew = gyroNorm ;
 for k=1:Nframes
     gyroNormNew(k,1) = normest( gyroNew(k,:) );
 end
     AHRSDataNew = AHRSData ;
     AHRSDataNew.gyro = gyroNew ;
     AHRSDataNew.gyroNorm = gyroNormNew ;
     meam_gyro_new = GetStaticStateFeature( AHRSDataNew,staticNum ) ;
else
    AHRSDataNew = AHRSData;
end



